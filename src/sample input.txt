/*-- snippets for generating interesting circle configurations --*/

		double phi = (1.0 + std::sqrt(5)) / 2.0;
		double A = std::sqrt(0.75 + phi);

		std::println("{} {} {}", -0.5, 0.0, 0.5);
		std::println("{} {} {}", 0.5, 0.0, 0.5);
		std::println("{} {} {}", 0.0, A, phi-0.5);
		std::println("{} {} {}", 0.0, -A, phi-0.5);

		///////////////

		auto pi = std::numbers::pi;
		auto R = 1.0 / (2.0 * std::sin(pi/7.0) );
		auto theta = 2.0 * pi / 7.0;
		auto pts = rv::iota(0, 7) | rv::transform(
				[=](auto n)->ici::point {
					auto angle = theta * static_cast<double>(n) + pi / 2.0;
					return {
						R * std::cos(angle),
						R * std::sin(angle)
					};
				}
			) | r::to<std::vector>();
		for (auto pt : pts) {
			std::println("{} {} {}", pt.x, pt.y, 0.5);
		}

		std::println("{} {} {}", 0.0, 0.0, R+0.5);
		std::println("{} {} {}", 0.0, 0.0, R - 0.5);

		///////////////
		
		auto pi = std::numbers::pi;
		auto pts = rv::iota(0, 4) | rv::transform(
				[=](auto n)->ici::point {
					auto theta = static_cast<double>(n) * pi / 2;
					auto rad = std::sqrt(2.0) / 2.0;
					auto x = rad * std::cos(theta);
					auto y = rad * std::sin(theta);
					x = (std::abs(x) < std::numeric_limits<float>::epsilon()) ? 0.0 : x;
					y = (std::abs(y) < std::numeric_limits<float>::epsilon()) ? 0.0 : y;
					return { x, y };
				}
			) | r::to<std::vector>();
		for (auto pt : pts) {
			std::println("{} {} {}", pt.x, pt.y, 1.0);
		}
		std::println("{} {} {}", 0.0, 0.0, std::sqrt(2.0) / 2.0 + 1.0);